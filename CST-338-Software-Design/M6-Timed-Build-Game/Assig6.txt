/*
 * Class: CST 338
 * Title: Module 6 - Timed "Build" Game
 * Author: Angela Cheng, Denis Mulalic, Janet Pham, Ben Textor
 * Date: April 12, 2022
 * 
 * Assig6.java
 */
import java.awt.BorderLayout;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.Random;

import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.TitledBorder;


public class Assig6
{

   public static void main(String[] args)
   {

      Control control = new Control();
      control.startGame();
      GameTimer gameTimer = new GameTimer(control);
      gameTimer.start();
      View.startButton.addActionListener(new ActionListener()
      {

         @Override
         public void actionPerformed(ActionEvent e)
         {

            gameTimer.switchTimer();
            if (gameTimer.stopped)
            {
               View.startButton.setText("Start");
            } 
            else
            {
               View.startButton.setText("Stop");
            }

         }

      });
      View.cannotPlay.addActionListener(new ActionListener()
      {

         public void actionPerformed(ActionEvent e)
         {
            control.Skip();

         }

      });
   }

}

// Model class that separates data from the visual class View
// and only provides data to the Control Class
class Model
{
   static int MAX_CARDS_PER_HAND = 56;
   static int MAX_PLAYERS = 2; // for now, we only allow 2 person games
   static int NUM_PLAY_AREA_CARDS = 3;

   static int skipCount = 0;
   static int computerSkips = 0;
   static int humanSkips = 0;
   static int clock = 0;
   static boolean playerWins = false;

   static boolean playerTurn = true;
   static boolean computerMoved = false;

   static boolean playerClickedCard = false;

   static boolean computerHasCard = false;

   static int computerPositionMatch = -1;

   static Card selectedCard = new Card();

   static Card[] playedCards = new Card[NUM_PLAY_AREA_CARDS];

   static Card[] winnings = new Card[14];
   static int winningsIndex = 0;

   static int NUM_CARDS_PER_HAND = 7;
   static int NUM_PLAYERS = 2;

   CardGameOutline timedBuildGame;
   static int numPlayers;
   static int numPacks;
   static int numJokersPerPack = 4;
   static int numUnusedCardsPerPack;
   static int numCardsPerHand;
   static Deck deck;

   private Hand[] hand;
   private Card[] unusedCardsPerPack;

   public Model()
   {
      timedBuildGame = new CardGameOutline(numPacks, numJokersPerPack,
         numUnusedCardsPerPack, unusedCardsPerPack, NUM_PLAYERS, 
         NUM_CARDS_PER_HAND);
   }

}

//View class that keeps output separate from the data in Model
//Only communicates with the control class
class View
{

   static JLabel winnerLabelText = new JLabel("", JLabel.CENTER);
   static JLabel computerSkipsLabel = new JLabel("CPU Skips: " + 0,
      JLabel.CENTER);
   static JLabel humanSkipsLabel = new JLabel("Player Skips: " + 0,
      JLabel.CENTER);
   static JLabel[] computerLabels;
   static JLabel[] humanLabels;
   static JLabel[] playedCardLabels = new JLabel[3];
   static JLabel[] playLabelText;
   static JLabel numcardsLabel;
   static JLabel timeLabel = new JLabel("", JLabel.CENTER);

   static JButton startButton = new JButton("Start");
   static JButton cannotPlay;

   static CardTable myCardTable;

   View(String title, int NUM_CARDS_PER_HAND, int NUM_PLAYERS, int MAX_PLAYERS,
      int MAX_CARDS_PER_HAND)
   {
      myCardTable = new CardTable(title, NUM_CARDS_PER_HAND, NUM_PLAYERS,
         MAX_PLAYERS, MAX_CARDS_PER_HAND);
      cannotPlay = new JButton("I Cannot Play");
   }

   static void startFrame()
   {
      myCardTable.setSize(800, 600);
      myCardTable.setLocationRelativeTo(null);
      myCardTable.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

   }

   JButton getCannotPlay() 
   {
      return cannotPlay;
   }

   // Method to rebuild the GUI with new icons
   public static void rebuildGUI(int NUM_CARDS_PER_HAND, int NUM_PLAYERS,
      int numCards, CardTable myCardTable, CardGameOutline timedBuildGame,
      JLabel[] humanLabels, JLabel[] computerLabels, JLabel[] playedCardLabels)
   {
      Icon tempIcon;
      timedBuildGame.sortHands();

      for (int k = 0; k < NUM_CARDS_PER_HAND; k++)
      {
         // human hand
         if (timedBuildGame.getHand(1).inspectCard(k) != null)
         {

            if (timedBuildGame.getHand(1).inspectCard(k).getCardError() ==
               false)
            {
               tempIcon = GUICard.getIcon(timedBuildGame.getHand(1).
                  inspectCard(k));
               View.humanLabels[k].setIcon(tempIcon);

            } 
            else
            {
               humanLabels[k].setIcon(null);
            }
         } 
         else
         {
            humanLabels[k].setIcon(null);
         }
      }

      for (int k = 0; k < NUM_CARDS_PER_HAND; k++)
      {
         if (timedBuildGame.getHand(0).inspectCard(k) != null)
         {
            if (timedBuildGame.getHand(0).inspectCard(k).getCardError() ==
               false)
            {
               // computer hand
               tempIcon = GUICard.getBackCardIcon();
               computerLabels[k].setIcon(tempIcon);
            } 
            else
            {
               computerLabels[k].setIcon(null);
            }
         } 
         else
         {
            computerLabels[k].setIcon(null);
         }
      }

      View.numcardsLabel.setText("In Deck: " + numCards);
   }

}

//Control class that uses both Model and View classes to create a functioning 
//program and keep those two classes from directly interacting
class Control
{
   public static Model model;
   private static View view;

   Control()
   {
      model = new Model();
      view = new View("Timed Build Game", Model.NUM_CARDS_PER_HAND,
         Model.NUM_PLAYERS, Model.MAX_PLAYERS, Model.MAX_CARDS_PER_HAND);

      View.computerLabels = new JLabel[Model.NUM_CARDS_PER_HAND];
      View.humanLabels = new JLabel[Model.NUM_CARDS_PER_HAND];
      View.playLabelText = new JLabel[Model.NUM_PLAYERS];

   }

   void rebuildTimeLabel(String time)
   {
      View.timeLabel.setText(time);
      View.myCardTable.repaint();
   }

   void startGame()
   {
      int k;
      Icon tempIcon;

      initCannotPlay();

      View.playLabelText[0] = new JLabel("Computer", JLabel.CENTER);
      View.playLabelText[1] = new JLabel("Your ", JLabel.CENTER);
      View.numcardsLabel = new JLabel("In Deck: " + 
         model.timedBuildGame.getDeck().getNumCards());

      // establish main frame in which program will run
      View.startFrame();

      // show everything to the user and load icons
      View.myCardTable.setVisible(true);
      GUICard.loadCardIcons();

      // CREATE LABELS ----------------------------------------------------

      // Gets the data from the hand classes and sets the icons and label data
      for (k = 0; k < Model.NUM_CARDS_PER_HAND; k++)
      {
         // human hand
         tempIcon = GUICard.getIcon(model.timedBuildGame.getHand(1).
            inspectCard(k));
         View.humanLabels[k] = new JLabel(tempIcon);

         // computer hand
         View.computerLabels[k] = new JLabel(GUICard.getBackCardIcon());
      }

      // adds the label data from the model class to the visual panels in view
      for (k = 0; k < Model.NUM_CARDS_PER_HAND; k++)
      {
         View.myCardTable.pnlHumanHand.add(View.humanLabels[k]);
         View.myCardTable.pnlComputerHand.add(View.computerLabels[k]);
      }

      // [0][0] on grid
      View.myCardTable.pnlPlayArea.add(View.timeLabel);
      // [0][1] on grid
      View.myCardTable.pnlPlayArea.add(new JLabel("", JLabel.CENTER));
      // [0][2] on grid
      View.myCardTable.pnlPlayArea.add(new JLabel("", JLabel.CENTER));
      // [0][3] in grid
      View.myCardTable.pnlPlayArea.add(new JLabel("", JLabel.CENTER));
      // [0][4] in grid
      View.myCardTable.pnlPlayArea.add(View.numcardsLabel);

      // [1][0] in grid
      View.myCardTable.pnlPlayArea.add(View.startButton); 
      // sets the playfield cards to null

      View.myCardTable.setVisible(true); // debug

      // [1][1]-[1][3]
      // sets the 3 playfield cards to start
      for (k = 0; k < Model.NUM_PLAY_AREA_CARDS; k++)
      {
         View.playedCardLabels[k] = new JLabel("", JLabel.CENTER);
         Model.playedCards[k] = model.timedBuildGame.getCardFromDeck();
         Icon temp = GUICard.getIcon(Model.playedCards[k]);
         View.playedCardLabels[k].setIcon(temp);
         View.myCardTable.pnlPlayArea.add(View.playedCardLabels[k]);

      }


      // adds other labels for layout and informational purposes
      // [1][4]
      View.myCardTable.pnlPlayArea.add(view.getCannotPlay());
      // [2][0]
      View.myCardTable.pnlPlayArea.add(View.computerSkipsLabel); 
      // [2][1]
      View.myCardTable.pnlPlayArea.add(new JLabel("", JLabel.CENTER));
      // [2][2]
      View.myCardTable.pnlPlayArea.add(View.winnerLabelText);
      // [2][3]
      View.myCardTable.pnlPlayArea.add(new JLabel("", JLabel.CENTER));
      // [2][4]
      View.myCardTable.pnlPlayArea.add(View.humanSkipsLabel);

      // adds mouse listeners to JLabels
      for (int currentCard = 0; currentCard < Model.NUM_CARDS_PER_HAND + 3;
         currentCard++)
      {

         if (currentCard > Model.NUM_CARDS_PER_HAND - 1)
         {
            attachMouseListener(View.playedCardLabels[currentCard - 7],
               model.timedBuildGame, View.myCardTable, View.winnerLabelText,
               currentCard);
         } 
         else
         {
            attachMouseListener(View.humanLabels[currentCard],
               model.timedBuildGame, View.myCardTable, View.winnerLabelText,
               currentCard);
         }
      }

      // show everything to the user
      View.myCardTable.setVisible(true);

      View.rebuildGUI(Model.NUM_CARDS_PER_HAND, Model.NUM_PLAYERS,
         model.timedBuildGame.getDeck().getNumCards(), View.myCardTable,
         model.timedBuildGame, View.humanLabels, View.computerLabels,
         View.playedCardLabels);
   }

   // mouse listener for card interaction
   private static void attachMouseListener(JLabel humanCard,
         CardGameOutline timedBuildGame, CardTable myCardTable,
         JLabel winnerLabelText, int cardPickedPosition)
   {
      humanCard.addMouseListener(new MouseAdapter()
      {
         @Override
         public void mousePressed(MouseEvent e)
         {

            cardClick(cardPickedPosition);
         }
      });
   }

   public void Skip()
   {
      if (Model.playerTurn == true)
      {
         Model.playerTurn = false;
         Model.humanSkips++;
         View.humanSkipsLabel.setText("Player Skips: " + Model.humanSkips);
         Model.skipCount++;
      }
   }

   public boolean enableCannotPlay(boolean bool)
   {
      view.getCannotPlay().setEnabled(bool);
      return true;
   }

   //
   // helper method for initializing cannot play button
   private void initCannotPlay()
   {
      view.getCannotPlay().setText("I Cannot Play");
      view.getCannotPlay().setVisible(true);
      int buttonWidth = 30, buttonHeight = 30;
      view.getCannotPlay().setBounds(20, 270, buttonWidth, buttonHeight);
      enableCannotPlay(true);
      // add(cannotPlay);

   }

   // method that holds the logic for playing the game, based on clicks
   public static void cardClick(int buttonNum)
   {
      if (model.timedBuildGame.getDeck().getNumCards() > 0)
      {
         if (Model.skipCount < 2)
         {
            // if it isn't the player's turn, search computer hand for matches
            // in each card pile
            if (Model.playerTurn == false)
            {
               for (int i = 0; i < Model.playedCards.length; i++)
               {
                  for (int j = 0; j < model.timedBuildGame.getHand(0).
                     getNumCards(); j++)
                  {
                     if (Model.computerHasCard == false)
                     {
                        if (GUICard.valueAsInt(Model.playedCards[i]) + 1 ==
                           GUICard.valueAsInt(model.timedBuildGame.getHand(0).
                           inspectCard(j)) || GUICard.valueAsInt(Model.
                           playedCards[i]) - 1 == GUICard.valueAsInt(model.
                              timedBuildGame.getHand(0).inspectCard(j)))
                        {
                           Model.computerHasCard = true;
                           Model.computerPositionMatch = j;
                           Model.playedCards[i] = 
                              model.timedBuildGame.getHand(0).playCard(j);
                           View.playedCardLabels[i].setIcon(GUICard.getIcon(
                              Model.playedCards[i]));
                           model.timedBuildGame.getHand(0).takeCard(model.
                              timedBuildGame.getCardFromDeck());
                           Model.playerTurn = true;
                           break;
                        }
                     }
                  }

               }
               // if the computer has a card set player turn to true and 
               // computerHasCard to false
               if (Model.computerHasCard == true)
               {
                  Model.computerHasCard = false;
                  Model.playerTurn = true;
                  Model.skipCount = 0;

               }
               // if the computer doesn't have a card set player turn to true
               // and increment skip
               else
               {
                  Model.computerSkips++;
                  View.computerSkipsLabel.setText("CPU Skips: " +
                     Model.computerSkips);
                  Model.playerTurn = true;
                  Model.skipCount++;
               }
               // rebuild GUI with all changes
               View.rebuildGUI(Model.NUM_CARDS_PER_HAND, Model.NUM_PLAYERS,
                  model.timedBuildGame.getDeck().getNumCards(),
                  View.myCardTable, model.timedBuildGame,View.humanLabels,
                  View.computerLabels, View.playedCardLabels);

            }
            // if player turn is true
            else
            {
               // if the player hasn't clicked a card from their hand only make 
               // changes when they do
               if (Model.playerClickedCard == false)
               {
                  if (buttonNum < 7)
                  {
                     Model.selectedCard =
                        model.timedBuildGame.getHand(1).playCard(buttonNum);
                     View.humanLabels[buttonNum].setIcon(null);
                     Model.playerClickedCard = true;
                  }

               }
               // Once a player has selected a card only let them click on one
               // of the piles
               else
               {
                  if (buttonNum > 6)
                  {
                     if (GUICard.valueAsInt(Model.selectedCard) + 1 == GUICard
                           .valueAsInt(Model.playedCards[buttonNum - 7])
                           || GUICard.valueAsInt(Model.selectedCard) - 1 ==
                           GUICard.valueAsInt(Model.playedCards[buttonNum - 7]))
                     {
                        Model.playedCards[buttonNum - 7] = Model.selectedCard;
                        View.playedCardLabels[buttonNum - 7].setIcon(GUICard.
                           getIcon(Model.selectedCard));
                        Model.selectedCard = new Card();
                        Model.playerClickedCard = false;
                        Model.playerTurn = false;
                        model.timedBuildGame.getHand(1).takeCard(model.
                           timedBuildGame.getCardFromDeck());
                        Model.skipCount = 0;
                     } 
                     else
                     {
                        model.timedBuildGame.getHand(1).
                           takeCard(Model.selectedCard);
                        View.humanLabels[6].setIcon(GUICard.
                           getIcon(Model.selectedCard));
                        model.timedBuildGame.sortHands();
                        Model.selectedCard = new Card();
                        Model.playerClickedCard = false;
                     }
                  }

               }

               // update gui with changes
               View.rebuildGUI(Model.NUM_CARDS_PER_HAND, Model.NUM_PLAYERS,
                  model.timedBuildGame.getDeck().getNumCards(),
                  View.myCardTable, model.timedBuildGame, View.humanLabels,
                  View.computerLabels, View.playedCardLabels);

            }
         } 
         else
         {
            for (int k = 0; k < Model.NUM_PLAY_AREA_CARDS; k++)
            {
               Model.playedCards[k] = model.timedBuildGame.getCardFromDeck();
               Icon temp = GUICard.getIcon(Model.playedCards[k]);
               View.playedCardLabels[k].setIcon(temp);
               Model.skipCount = 0;

            }
         }

      } 
      else
      {
         if (Model.computerSkips > Model.humanSkips)
         {
            View.winnerLabelText.setText("Human Wins!");
         } 
         else if ((Model.computerSkips < Model.humanSkips))
         {
            View.winnerLabelText.setText("Computer Wins!");
         } 
         else
         {
            View.winnerLabelText.setText("Tie game!");
         }
      }

   }

}

//previously created (revised) card class from Module 3
class Card
{
   // public enum
   public enum Suit
   {
      clubs, diamonds, hearts, spades
   };

   static Suit[] suitRanks =
      { Suit.clubs, Suit.diamonds, Suit.hearts, Suit.spades };

   public static char[] valuRanks =
    {'1', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'X', 'A'};

   // private member
   private char value;
   private Suit suit;
   private boolean cardError;

   //bubble sort cards based on valuRanks
   static void arraySort(Card[] card, int arraySize)
   {
      for (int j = 0; j < arraySize; j++)
      {
         for (int k = 1; k < (arraySize - j); k++)
         {
            int card1 = cardRank(card[k - 1]);
            int card2 = cardRank(card[k]);

            if (card1 > card2)
            {
               Card tmp = new Card(card[k - 1]);

               card[k - 1] = card[k];
               card[k] = tmp;
            }
         }
      }
   }

   //used to simplify arraySort -- returns the valuRank of a given card
   static int cardRank(Card card)
   {
      for (int i = 0; i < valuRanks.length; i++)
      {
         if (card.value == valuRanks[i])
         {
            return i;
         }
      }
      return -1;
   }

   // Default constructor sets a card to 'A' and 'spades'
   public Card()
   {
      set('A', Card.Suit.spades);
   }

   // Card class constructor
   public Card(char value, Suit suit)
   {
      set(value, suit);
   }

   // copy constructor - create duplicate of the original
   public Card(Card origCard)
   {
      set(origCard.getValue(), origCard.getSuit());
   }

   /*
    * Purpose: use to display the card Result(s): If cardError is true return a
    * statement that reflects the fact, like its " [invalid] "
    */
   public String toString()
   {
      if (this.cardError == true)
      {

         return "** illegal **";
      } 
      else
         return getValue() + " of " + getSuit();

   }

   //sets a card using char and Suit arguments
   public boolean set(char value, Suit suit)
   {
      if (isValid(value, suit))
      {
         this.value = value;
         this.suit = suit;
         cardError = false;
         return true;
      } 
      else
      {
         cardError = true;
         return false;
      }
   }

   // Accessor method for value
   public char getValue()
   {
      return this.value;
   }

   // Accessor method for suit
   public Suit getSuit()
   {
      return this.suit;
   }

   // Accessor method for cardError value
   public boolean getCardError()
   {
      return this.cardError;
   }

   // Boolean check for all members*
   public boolean equals(Card card)
   {
      if (this.value == card.value && this.suit == card.suit && card.cardError
         == false)
      {
         return true;
      } 
      else
      {
         return false;
      }
   }

   /*
    *Purpose: private helper method that returns true or false, depending on the
    * parameters
    */
   private boolean isValid(char value, Suit suit)
   {
      switch (value)
      {
      case 'A':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'T':
      case 'J':
      case 'Q':
      case 'K':
      case 'X':
         break;
      default:
         return false;
      }

      switch (suit)
      {
      case clubs:
      case diamonds:
      case hearts:
      case spades:
         return true;
      default:
         return false;
      }
   }
}

/*
 * A class that represents the cards held by a single player.
 */
class Hand
{
   public static final int MAX_CARDS = 100;
   private Card[] myCards;
   private int numCards = 0;

   // Default constructor for the hand class
   public Hand()
   {
      myCards = new Card[MAX_CARDS];
   }

   // Removes by setting myCard array to null
   public void resetHand()
   {
      myCards = new Card[MAX_CARDS];
      numCards = 0;
   }

   /*
    * Takes as argument a card and adds it to the myCards array and tests for
    * capacity
    */
   public boolean takeCard(Card card)
   {
      if (card != null)
      {
         if (card.getCardError() == false && numCards < MAX_CARDS)
         {
            myCards[numCards] = new Card(card.getValue(), card.getSuit());
            numCards++;
            return true;
         } 
         else
         {
            return false;
         }
      } 
      else
      {
         return false;
      }
   }

   /*
    * Outputs a card in the array and replaces its spot in the array with an
    * invalid card
    */
   public Card playCard()
   {
      Card returnCard = new Card();
      if (numCards >= 1)
      {
         returnCard = myCards[numCards - 1];

         if (returnCard == null)
         {
            while (returnCard == null)
            {
               numCards--;
               returnCard = myCards[numCards - 1];
            }
         }

         numCards--;
         return returnCard;
      }

      else
      {
         // Return a "bad" card
         returnCard.set('v', Card.Suit.spades);
         return returnCard;
      }
   }

   //from assignment description of hand class changes
   public Card playCard(int cardIndex)
   {
      if (numCards == 0)
      {
         // creates a card that does not work
         return new Card('M', Card.Suit.spades);
      }
      // Decreases numCards
      Card card = myCards[cardIndex];

      numCards--;
      for (int i = cardIndex; i < numCards; i++)
      {
         myCards[i] = myCards[i + 1];
      }

      myCards[numCards] = null;
      return card;
   }

   // Saves the entire hand to a string and returns it
   public String toString()
   {
      String handString = "Hand = ( ";
      for (int k = 0; k <= numCards - 1; k++)
      {
         if (myCards[k].getCardError() != true)
         {
            if (k == numCards - 1)
            {
               handString = handString + myCards[k].toString() + " )";
            } 
            else
            {
               handString = handString + myCards[k].toString() + ", ";
            }
         }
      }
      return handString;
   }

   // Returns the current number of cards in the array
   public int getNumCards()
   {
      return this.numCards;
   }

   // Returns a specific card from the array, or an invalid card if
   // index is bad
   public Card inspectCard(int k)
   {
      if (k > numCards)
      {
         return new Card('v', Card.Suit.spades);
      } 
      else
      {
         return myCards[k];
      }
   }

   //calls arraysort to sort cards
   void sort()
   {
      Card.arraySort(myCards, numCards);
   }
}

/*
 * A class that represents the source of the cards for dealing and, as the game
 * progresses, the place from which players can receive new cards (say, as they
 * pick cards "from the deck" or when future hands are to be dealt from the same
 * deck).
 */
class Deck
{
   public final int MAX_CARDS = 6 * 56; // A maximum of six packs
   private static Card[] masterPack = new Card[56];
   private Card[] cards;
   private int topCard = 0;
   private static boolean initDeck = false;

   //added variable to truck number of packs
   private int packCount = 0;

   // Constructor
   public Deck()
   {
      allocateMasterPack();
      init(1);
      cards = masterPack;
      packCount = 1;
   }

   // Constructors
   public Deck(int numPacks)
   {
      allocateMasterPack();
      init(numPacks);
      cards = masterPack;
      packCount = numPacks;
   }

   //New method to add a card and check for how many copies there are against 
   //the number of decks in play 
   public boolean addCard(Card card)
   {
      int cardRedundancy = 0;
      for (int i = 0; i < topCard; i++)
      {
         if (cards[i] != null)
         {
            if (cards[i].equals(card))
            {
               cardRedundancy++;
            }
         }
      }
      if (cardRedundancy < packCount)
      {
         topCard++;
         cards[topCard - 1] = card;
         return true;
      } 
      else
      {
         return false;
      }

   }

   //New method to check if a card exists in the deck and remove it. Top card
   // is placed where the removed card was.
   public boolean removeCard(Card card)
   {
      for (int i = 0; i < topCard; i++)
      {
         if (cards[i].equals(card))
         {
            cards[i] = cards[topCard - 1];
            cards[topCard - 1] = null;
            topCard--;
            return true;
         }
      }
      return false;
   }

   // sorts the cards by rank using Card.arraySort
   void sort()
   {
      Card.arraySort(cards, topCard - 1);
   }

   // Re-populates the cards[] with new cards
   public void init(int numPacks)
   {
      cards = null;
      topCard = 0;
      cards = new Card[numPacks * 56];
      for (int i = 0, j = 0; i <= (numPacks * 52) - 1; i++, j++)
      {
         if (j > 51)
            j = 0;
         cards[i] = masterPack[j];
         topCard++;
      }
   }

   //New method to get the number of cards in the deck (topCard) 
   public int getNumCards()
   {
      return topCard;
   }

   // Shuffles the cards[] by iteraing and placing card in each index randomly
   public void shuffle()
   {
      Card tempCard;
      Random rand = new Random();
      int firstCard;
      int secondCard;

      for (int i = 0; i < 1000; i++)
      {
         firstCard = rand.nextInt(topCard);
         secondCard = rand.nextInt(topCard);
         tempCard = cards[firstCard];
         cards[firstCard] = cards[secondCard];
         cards[secondCard] = tempCard;
      }
   }

   // Returns and removes the card in the top occupied position of cards[]
   public Card dealCard()
   {
      Card dealtCard = new Card();
      if (topCard >= 1)
      {
         dealtCard = cards[topCard - 1];
         removeCard(cards[topCard - 1]);
         return dealtCard;
      }
      dealtCard.set('v', Card.Suit.clubs);
      return dealtCard;
   }

   // Accessor for individual card
   public Card inspectCard(int k)
   {
      if (k > cards.length)
      {
         return new Card('v', Card.Suit.spades);
      } 
      else
      {
         Card card = new Card();
         card = cards[k];
         return card;
      }
   }

   // Private method that will be called by the constructor
   //is NOT supposed to add jokers according to instructions
   //jokers are added to deck for PhaseII in the randomCardGenerator
   private static void allocateMasterPack()
   {
      if (!initDeck)
      {
         int cardNum = 0;
         char[] cardVal =
            { 'A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K' };
         for (Card.Suit suit : Card.Suit.values())
         {
            for (char value : cardVal)
            {
               if (cardNum < 52)
               {
                  masterPack[cardNum] = new Card(value, suit);
                  cardNum++;
               }
            }
         }
         initDeck = true;
      }
   }
}

class CardTable extends JFrame
{

   public JPanel pnlComputerHand, pnlHumanHand, pnlPlayArea;

   CardTable(String title, int numCardsPerHand, int numPlayers, int MAX_PLAYERS,
      int MAX_CARDS_PER_HAND)
   {
      super(title);

      if (numPlayers <= MAX_PLAYERS && numCardsPerHand <= MAX_CARDS_PER_HAND)
      {

         pnlComputerHand = new JPanel();
         pnlPlayArea = new JPanel(new GridLayout(3, 5));
         pnlHumanHand = new JPanel();

         setLayout(new BorderLayout(20, 10));
         add(pnlComputerHand, BorderLayout.NORTH);
         add(pnlPlayArea, BorderLayout.CENTER);
         add(pnlHumanHand, BorderLayout.SOUTH);

         pnlComputerHand.setBorder(new TitledBorder("Computer Hand"));
         pnlPlayArea.setBorder(new TitledBorder("Playing Area"));
         pnlHumanHand.setBorder(new TitledBorder("Your Hand"));

         //         startButton.addActionListener(this);
         //         pnlPlayArea.add(startButton);
         //         startButton.setText("Start: ");
      }
   }

}

// CardGameOutline handles the data for the game
class CardGameOutline
{
   private static final int MAX_PLAYERS = 50;

   private int numPlayers;
   private int numPacks; // # standard 52-card packs per deck
   // ignoring jokers or unused cards
   private int numJokersPerPack; // if 2 per pack & 3 packs per deck, get 6
   private int numUnusedCardsPerPack; // # cards removed from each pack
   private int numCardsPerHand; // # cards to deal each player
   private Deck deck; // holds the initial full deck and gets
   // smaller (usually) during play
   private Hand[] hand; // one Hand for each player
   private Hand tableHand;
   private Card[] unusedCardsPerPack; // an array holding the cards not used
   // in the game. e.g. pinochle does not
   // use cards 2-8 of any suit

   public CardGameOutline(int numPacks, int numJokersPerPack,
      int numUnusedCardsPerPack, Card[] unusedCardsPerPack, int numPlayers,
      int numCardsPerHand)
   {
      int k;

      // filter bad values
      if (numPacks < 1 || numPacks > 6)
         numPacks = 1;
      if (numJokersPerPack < 0 || numJokersPerPack > 4)
         numJokersPerPack = 0;
      if (numUnusedCardsPerPack < 0 || numUnusedCardsPerPack > 50) // > 1 card
         numUnusedCardsPerPack = 0;
      if (numPlayers < 1 || numPlayers > MAX_PLAYERS)
         numPlayers = 4;
      // one of many ways to assure at least one full deal to all players
      if (numCardsPerHand < 1 || numCardsPerHand > numPacks * 
         (52 - numUnusedCardsPerPack) / numPlayers) numCardsPerHand = numPacks *
         (52 - numUnusedCardsPerPack) / numPlayers;

      // allocate
      this.unusedCardsPerPack = new Card[numUnusedCardsPerPack];
      this.hand = new Hand[numPlayers];
      for (k = 0; k < numPlayers; k++)
         this.hand[k] = new Hand();
      deck = new Deck(numPacks);
      // deal();//test

      // assign to members
      this.numPacks = numPacks;
      this.numJokersPerPack = numJokersPerPack;
      this.numUnusedCardsPerPack = numUnusedCardsPerPack;
      this.numPlayers = numPlayers;
      this.numCardsPerHand = numCardsPerHand;
      for (k = 0; k < numUnusedCardsPerPack; k++)
         this.unusedCardsPerPack[k] = unusedCardsPerPack[k];

      this.tableHand = new Hand();

      // prepare deck and shuffle
      newGame();
   }

   // constructor overload/default for game like bridge
   public CardGameOutline()
   {
      this(1, 0, 0, null, 4, 13);
   }

   public Hand getHand(int k)
   {
      // hands start from 0 like arrays

      // on error return automatic empty hand
      if (k < 0 || k >= numPlayers)
         return new Hand();

      return hand[k];
   }

   // added this to retrieve the deck from the outline
   public Deck getDeck()
   {
      return deck;
   }

   public Card getCardFromDeck()
   {
      return deck.dealCard();
   }

   public int getNumCardsRemainingInDeck()
   {
      return deck.getNumCards();
   }

   public void newGame()
   {
      int k, j;

      // clear the hands
      for (k = 0; k < numPlayers; k++)
         hand[k].resetHand();

      // restock the deck
      deck.init(numPacks);

      // remove unused cards
      for (k = 0; k < numUnusedCardsPerPack; k++)
         deck.removeCard(unusedCardsPerPack[k]);

      // add jokers
      for (k = 0; k < numPacks; k++)
         for (j = 0; j < numJokersPerPack; j++)
            deck.addCard(new Card('X', Card.Suit.values()[j]));

      // shuffle the cards
      deck.shuffle();
      deal();
   }

   public boolean deal()
   {
      // returns false if not enough cards, but deals what it can
      int k, j;
      boolean enoughCards;

      // clear all hands
      for (j = 0; j < numPlayers; j++)
         hand[j].resetHand();

      enoughCards = true;
      for (k = 0; k < numCardsPerHand && enoughCards; k++)
      {
         for (j = 0; j < numPlayers; j++)
         {
            if (deck.getNumCards() > 0)
               hand[j].takeCard(deck.dealCard());
            else
            {
               enoughCards = false;
               break;
            }
         }
      }
      return enoughCards;
   }

   void sortHands()
   {
      int k;

      for (k = 0; k < numPlayers; k++)
         hand[k].sort();
   }

   Card playCard(int playerIndex, int cardIndex)
   {
      // returns bad card if either argument is bad
      if (playerIndex < 0 || playerIndex > numPlayers - 1 || cardIndex < 0 ||
         cardIndex > numCardsPerHand - 1)
      {
         // Creates a card that does not work
         return new Card('M', Card.Suit.spades);
      }

      // return the card played
      return hand[playerIndex].playCard(cardIndex);

   }

   boolean takeCard(int playerIndex)
   {
      // returns false if either argument is bad
      if (playerIndex < 0 || playerIndex > numPlayers - 1)
         return false;

      // Are there enough Cards?
      if (deck.getNumCards() <= 0)
         return false;

      return hand[playerIndex].takeCard(deck.dealCard());
   }
}

// GUICard Class, loads Icon arrays with cards
class GUICard
{
   // 14 = A thru K + joker
   private static Icon[][] iconCards = new ImageIcon[14][4];

   private static Icon iconBack;
   static boolean iconsLoaded = false;

   // runs loadCardIcons() to set the array of Icons and iconBack
   GUICard()
   {
      loadCardIcons();
   }

   // loads the card Icons into an array ONCE
   static void loadCardIcons()
   {
      if (iconsLoaded == false)
      {
         String path = "images/";
         String str = "";

         for (int j = 0; j < 14; j++)
         {
            for (int k = 0; k < 4; k++)
            {
               str = path + turnIntIntoCardValue(j) + turnIntIntoCardSuit(k) +
                  ".gif";
               iconCards[j][k] = new ImageIcon(str);
            }
         }

         iconBack = new ImageIcon(path + "BK.gif");
         iconsLoaded = true;
      }
   }

   // returns the back-of-card icon
   static public Icon getBackCardIcon()
   {
      return iconBack;
   }

   // gets the icon for the argument card
   static public Icon getIcon(Card card)
   {
      if (card != null && card.getCardError() == false)
      {

         return iconCards[valueAsInt(card)][suitAsInt(card)];
      } 
      else
      {
         return null;
      }
   }

   // Returns suit as int

   static int suitAsInt(Card card)
   {
      int value = -1;

      if (card != null && card.getCardError() == false)
      {
         String suit = card.getSuit().name();

         switch (suit)
         {
         case "clubs":
         {
            value = 0;
         }
         break;
         case "diamonds":
         {
            value = 1;
         }
         break;
         case "hearts":
         {
            value = 2;
         }
         break;
         case "spades":
         {
            value = 3;
         }
         break;
         }
         return value;
      } 
      else
      {
         return value;
      }
   }

   // returns value as int
   static int valueAsInt(Card card)
   {
      char valueChar = card.getValue();
      int value = 0;
      switch (valueChar)
      {
      case 'A':
      {
         value = 0;
      }
      break;
      case '2':
      {
         value = 1;
      }
      break;
      case '3':
      {
         value = 2;
      }
      break;
      case '4':
      {
         value = 3;
      }
      break;
      case '5':
      {
         value = 4;
      }
      break;
      case '6':
      {
         value = 5;
      }
      break;
      case '7':
      {
         value = 6;
      }
      break;
      case '8':
      {
         value = 7;
      }
      break;
      case '9':
      {
         value = 8;
      }
      break;
      case 'T':
      {
         value = 9;
      }
      break;
      case 'J':
      {
         value = 10;
      }
      break;
      case 'Q':
      {
         value = 11;
      }
      break;
      case 'K':
      {
         value = 12;
      }
      break;
      case 'X':
      {
         value = 13;
      }
      break;
      }

      return value;

   }

   // turns 0 - 13 into "A", "2", "3", ... "Q", "K", "X"
   static String turnIntIntoCardValue(int k)
   {
      String temp = "";
      switch (k)
      {
      case 0:
      {
         temp = "A";
      }
      break;
      case 1:
      {
         temp = "2";
      }
      break;
      case 2:
      {
         temp = "3";
      }
      break;
      case 3:
      {
         temp = "4";
      }
      break;
      case 4:
      {
         temp = "5";
      }
      break;
      case 5:
      {
         temp = "6";
      }
      break;
      case 6:
      {
         temp = "7";
      }
      break;
      case 7:
      {
         temp = "8";
      }
      break;
      case 8:
      {
         temp = "9";
      }
      break;
      case 9:
      {
         temp = "T";
      }
      break;
      case 10:
      {
         temp = "J";
      }
      break;
      case 11:
      {
         temp = "Q";
      }
      break;
      case 12:
      {
         temp = "K";
      }
      break;
      case 13:
      {
         temp = "X";
      }
      break;
      case 14:
      {
         temp = "B";
      }
      break;
      }
      return temp;
   }

   // turns 0 - 3 into "C", "D", "H", "S"
   static String turnIntIntoCardSuit(int j)
   {
      // an idea for another helper method (do it differently if you wish)
      String temp = "";
      switch (j)
      {
      case 0:
      {
         temp = "C";
      }
      break;
      case 1:
      {
         temp = "D";
      }
      break;
      case 2:
      {
         temp = "H";
      }
      break;
      case 3:
      {
         temp = "S";
      }
      break;
      case 4:
      {
         temp = "K";
      }
      break;
      }
      return temp;
   }

}

class GameTimer extends Thread
{
   static int gameClock = 0;
   static final int PAUSE = 1000; // This is one second
   static String gameClockString = "0:00";
   static boolean stopped = true;
   Control control;

   public GameTimer(Control control)
   {
      this.control = control;
   }

   public void run()
   {
      while (true)
      {
         if (!stopped)
         {
            control.rebuildTimeLabel(gameClockString);
            gameClock++;
            gameClockString = (gameClock / 60) + ":" + 
               String.format("%02d", (gameClock % 60));
            doNothing(PAUSE);
         } 
         else
         {
            control.rebuildTimeLabel(gameClockString);
         }
         // System.out.println(gameClockString);
      }
   }

   public static String showTimer()
   {
      return gameClockString;
   }

   public static int timerAsInt()
   {
      return gameClock;
   }

   public static void switchTimer()
   {
      if (stopped)
      {
         stopped = false;
      } 
      else
      {
         stopped = true;
      }
   }

   private void doNothing(int milliseconds)
   {
      try
      {
         Thread.sleep(milliseconds);
      } catch (InterruptedException e)
      {
         System.exit(0);
      }
   }
}