import java.util.Random;
import java.awt.*;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.border.TitledBorder;
import javax.swing.*;
//import Card.Suit;

public class Assig5_2
{
   static int NUM_CARDS_PER_HAND = 7;
   static int  NUM_PLAYERS = 2;
   static JLabel[] computerLabels = new JLabel[NUM_CARDS_PER_HAND];
   static JLabel[] humanLabels = new JLabel[NUM_CARDS_PER_HAND];  
   static JLabel[] playedCardLabels  = new JLabel[NUM_PLAYERS]; 
   static JLabel[] playLabelText  = new JLabel[NUM_PLAYERS]; 
   
   public static void main(String[] args)
   {      
      int k = 0;
      Icon tempIcon;
      
      // establish main frame in which program will run
      CardTable myCardTable 
         = new CardTable("CardTable", NUM_CARDS_PER_HAND, NUM_PLAYERS);
      myCardTable.setSize(800, 600);
      myCardTable.setLocationRelativeTo(null);
      myCardTable.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

      // show everything to the user
      myCardTable.setVisible(true);
    
      // CREATE LABELS ----------------------------------------------------
      //code goes here ...
      GUICard.loadCardIcons();
      for(k = 0; k < NUM_CARDS_PER_HAND; k++)
      {         
         tempIcon = GUICard.getIcon(randomCardGenerator());      
         humanLabels[k] = new JLabel(tempIcon);
         computerLabels[k] = new JLabel(GUICard.getBackCardIcon());        
      }
      
      // ADD LABELS TO PANELS -----------------------------------------
      //code goes here ...
      for(k = 0; k < NUM_CARDS_PER_HAND; k++)
      {
         myCardTable.pnlHumanHand.add(humanLabels[k]);
         myCardTable.pnlComputerHand.add(computerLabels[k]);
      }
      
      // and two random cards in the play region (simulating a computer/hum ply)
      //code goes here ...
      for(k = 0; k < NUM_PLAYERS; k++)
      {
         tempIcon = GUICard.getIcon(randomCardGenerator());
         playedCardLabels[k] = new JLabel(tempIcon);
      }
      
      playLabelText[0] = new JLabel("Computer", 0);
      playLabelText[1] = new JLabel("Human", 0);
      
      for(k = 0; k < NUM_PLAYERS; k++)
      {
         myCardTable.pnlPlayArea.add(playedCardLabels[k]);
      }
      
      myCardTable.pnlPlayArea.add(playLabelText[0]);
      myCardTable.pnlPlayArea.add(playLabelText[1]);
      // show everything to the user
      myCardTable.setVisible(true);

   }
   
   //generate a random card from a shuffled deck. Manually inserts 
   //jokers into deck since instructions state it needs them, but not 
   //to add them when allocating the masterPack
   static Card randomCardGenerator()
   {
      Deck randDeck = new Deck(1);
      randDeck.addCard(new Card('X', Card.Suit.clubs));
      randDeck.addCard(new Card('X', Card.Suit.hearts));
      randDeck.addCard(new Card('X', Card.Suit.diamonds));
      randDeck.addCard(new Card('X', Card.Suit.spades));
      Random randIndex = new Random(); 
      int rand = randIndex.nextInt(randDeck.getNumCards()); 
      System.out.println(rand);
      return randDeck.inspectCard(randIndex.nextInt(randDeck.getNumCards()));
   }
   

}

//Class that controls the position of panels and cards in the GUI
class CardTable extends JFrame
{
   static int MAX_CARDS_PER_HAND = 56;
   static int MAX_PLAYERS = 2; // for now, we only allow 2 person games

   private int numCardsPerHand;
   private int numPlayers;

   public JPanel pnlComputerHand, pnlHumanHand, pnlPlayArea;

   CardTable(String title, int numCardsPerHand, int numPlayers)
   {
      super(title);

      if(numPlayers <= MAX_PLAYERS && numCardsPerHand <= MAX_CARDS_PER_HAND)
      {  
         this.numCardsPerHand = numCardsPerHand;
         this.numPlayers = numPlayers;

         pnlComputerHand = new JPanel();
         pnlPlayArea = new JPanel(new GridLayout(2, 2));
         pnlHumanHand = new JPanel();

         setLayout(new BorderLayout(20, 10));
         add(pnlComputerHand, BorderLayout.NORTH );
         add(pnlPlayArea, BorderLayout.CENTER);
         add(pnlHumanHand, BorderLayout.SOUTH);

         pnlComputerHand.setBorder(new TitledBorder("Computer Hand"));
         pnlPlayArea.setBorder(new TitledBorder("Playing Area"));
         pnlHumanHand.setBorder(new TitledBorder("Your Hand"));        
      }  
   }
   
   //returns the number of cards per hand
   int getnumCardsPerHand()
   {
      return this.numCardsPerHand;
   }
   
   //returns the number of players
   int getNumPlayers()
   {
      return this.numPlayers;
   }
}

class GUICard
{
   private static Icon[][] iconCards = new ImageIcon[14][4]; 
   private static Icon iconBack;
   static boolean iconsLoaded = false;

   //runs loadCardIcons() to set the array of Icons and iconBack
   GUICard()
   {
      loadCardIcons();
   }
   
   //loads the card Icons into an array ONCE
   static void loadCardIcons()
   {
      if (iconsLoaded == false)
      {
         String path = "images//"; 
         String str = "";

         for (int j = 0; j < 14; j++)
         {
            for (int k = 0; k < 4; k++)
            {
               str = path + turnIntIntoCardValue(j) + turnIntIntoCardSuit(k) 
                  + ".gif";
               iconCards[j][k] = new ImageIcon(str);
            }
         }

         iconBack = new ImageIcon(path + "BK.gif");
         iconsLoaded = true;
      }
   }
   
   //returns the back-of-card icon 
   static public Icon getBackCardIcon()
   {
      return iconBack;
   }
   
   // gets the icon for the argument card
   static public Icon getIcon(Card card)
   {
      return iconCards[valueAsInt(card)][suitAsInt(card)];
   }
   
   // Returns suit as int
   static int suitAsInt(Card card)
   {
      String suit = card.getSuit().name();
      int value = 0;
      switch (suit)
      {
      case "clubs":
      {
         value = 0;
      }
         break;
      case "diamonds":
      {
         value = 1;
      }
         break;
      case "hearts":
      {
         value = 2;
      }
         break;
      case "spades":
      {
         value = 3;
      }
         break;
      }
      return value;
   }

   //returns value as int
   static int valueAsInt(Card card)
   {
      char valueChar = card.getValue();
      int value = 0;
      switch (valueChar)
      {
      case 'A':
      {
         value = 0;
      }
         break;
      case '2':
      {
         value = 1;
      }
         break;
      case '3':
      {
         value = 2;
      }
         break;
      case '4':
      {
         value = 3;
      }
         break;
      case '5':
      {
         value = 4;
      }
         break;
      case '6':
      {
         value = 5;
      }
         break;
      case '7':
      {
         value = 6;
      }
         break;
      case '8':
      {
         value = 7;
      }
         break;
      case '9':
      {
         value = 8;
      }
         break;
      case 'T':
      {
         value = 9;
      }
         break;
      case 'J':
      {
         value = 10;
      }
         break;
      case 'Q':
      {
         value = 11;
      }
         break;
      case 'K':
      {
         value = 12;
      }
         break;
      }

      return value;
   }

   // turns 0 - 13 into "A", "2", "3", ... "Q", "K", "X"
   static String turnIntIntoCardValue(int k)
   {
      String temp = "";
      switch (k)
      {
      case 0:
      {
         temp = "A";
      }
         break;
      case 1:
      {
         temp = "2";
      }
         break;
      case 2:
      {
         temp = "3";
      }
         break;
      case 3:
      {
         temp = "4";
      }
         break;
      case 4:
      {
         temp = "5";
      }
         break;
      case 5:
      {
         temp = "6";
      }
         break;
      case 6:
      {
         temp = "7";
      }
         break;
      case 7:
      {
         temp = "8";
      }
         break;
      case 8:
      {
         temp = "9";
      }
         break;
      case 9:
      {
         temp = "T";
      }
         break;
      case 10:
      {
         temp = "J";
      }
         break;
      case 11:
      {
         temp = "Q";
      }
         break;
      case 12:
      {
         temp = "K";
      }
         break;
      case 13:
      {
         temp = "X";
      }
         break;
      case 14:
      {
         temp = "B";
      }
         break;
      }
      return temp;
   }

   // turns 0 - 3 into "C", "D", "H", "S"
   static String turnIntIntoCardSuit(int j)
   {
      // an idea for another helper method (do it differently if you wish)
      String temp = "";
      switch (j)
      {
      case 0:
      {
         temp = "C";
      }
         break;
      case 1:
      {
         temp = "D";
      }
         break;
      case 2:
      {
         temp = "H";
      }
         break;
      case 3:
      {
         temp = "S";
      }
         break;
      case 4:
      {
         temp = "K";
      }
         break;
      }
      return temp;
   }
}

// previously created (revised) classes from Module 3
class Card
{
   // public enum
   public enum Suit
   {
      clubs, diamonds, hearts, spades
   };
   static Suit[] suitRanks = {Suit.clubs, Suit.diamonds, Suit.hearts,
         Suit.spades};

   public static char[] valuRanks =
   { '1', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 
      'K', 'X', 'A' };
   // private member
   private char value;
   private Suit suit;
   private boolean cardError;

   //bubble sort cards based on valuRanks
   static void arraySort(Card[] card, int arraySize)
   {
      for (int j = 0; j < arraySize; j++)
      {
         for (int k = 1; k < (arraySize - j); k++)
         {
            int card1 = cardRank(card[k - 1]);
            int card2 = cardRank(card[k]);

            if (card1 > card2)
            {
               Card tmp = new Card(card[k - 1]);

               card[k - 1] = card[k];
               card[k] = tmp;
            }
         }
      }
   }
   
//used to simplify arraySort -- returns the valuRank of a given card
   static int cardRank(Card card)
   {
      for (int i = 0; i < valuRanks.length; i++)
      {
         if (card.value == valuRanks[i])
         {
            return i;
         }
      }
      return -1;
   }

   // Default constructor sets a card to 'A' and 'spades'
   public Card()
   {
      set('A', Card.Suit.spades);
   }

   // Card class constructor
   public Card(char value, Suit suit)
   {
      set(value, suit);
   }

   // copy constructor - create duplicate of the original
   public Card(Card origCard)
   {
      set(origCard.getValue(), origCard.getSuit());
   }

   /*
    * Purpose: use to display the card Result(s): If cardError is true return a
    * statement that reflects the fact, like its " [invalid] "
    */
   public String toString()
   {
      if (this.cardError == true)
         return "** illegal **";
      else
         return getValue() + " of " + getSuit();

   }

   public boolean set(char value, Suit suit)
   {
      if (isValid(value, suit))
      {
         this.value = value;
         this.suit = suit;
         cardError = false;
         return true;
      } 
      else
      {
         cardError = true;
         return false;
      }
   }

   // Accessor method for value
   public char getValue()
   {
      return this.value;
   }

   // Accessor method for suit
   public Suit getSuit()
   {
      return this.suit;
   }

   // Accessor method for cardError value
   public boolean getCardError()
   {
      return this.cardError;
   }

   // Boolean check for all members*
   public boolean equals(Card card)
   {
      if (this.value == card.value && this.suit == card.suit 
         && card.cardError == false)
      {
         return true;
      } 
      else
      {
         return false;
      }
   }

   /*
    * Purpose: private helper method that returns true or false, depending on 
    * the parameters
    */
   private boolean isValid(char value, Suit suit)
   {
      switch (value)
      {
      case 'A':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'T':
      case 'J':
      case 'Q':
      case 'K':
      case 'X':
         break;
      default:
         return false;
      }

      switch (suit)
      {
      case clubs:
      case diamonds:
      case hearts:
      case spades:
         return true;
      default:
         return false;
      }
   }
}

/*
 * A class that represents the cards held by a single player.
 */
class Hand
{
   public static final int MAX_CARDS = 100;
   private Card[] myCards;
   private int numCards = 0;

   // Default constructor for the hand class
   public Hand()
   {
      myCards = new Card[MAX_CARDS];
   }

   // Removes by setting myCard array to null
   public void resetHand()
   {
      myCards = new Card[MAX_CARDS];
      numCards = 0;
   }

   /*
    * Takes as argument a card and adds it to the myCards array and tests for
    * capacity
    */
   public boolean takeCard(Card card)
   {
      if(card != null)
      {
         if (card.getCardError() == false && numCards < MAX_CARDS)
         {
            myCards[numCards] = new Card(card.getValue(), card.getSuit());
            numCards++;
            return true;
         } 
         else
         {
            return false;
         }
      }
      else
      {
         return false;
      }
   }

   /*
    * Outputs a card in the array and replaces its spot in the array with an
    * invalid card
    */
   public Card playCard()
   {
      Card returnCard = new Card();
      if (numCards >= 1)
      {
         returnCard = myCards[numCards - 1];
         
         if(returnCard == null)
         {
            while(returnCard == null)
            {
               numCards--;
               returnCard = myCards[numCards - 1];
            }
         }

         numCards--;
         return returnCard;
      }     
      else
      {
         // Return a "bad" card
         returnCard.set('v', Card.Suit.spades);
         return returnCard;
      }
   }
   //from assignment description of hand class changes
   public Card playCard(int cardIndex)
   {
      if(numCards == 0)
      {
         //creates a card that does not work
         return new Card('M', Card.Suit.spades);
      }
      //Decreases numCards
      Card card = myCards[cardIndex];
      
      numCards--;
      for(int i = cardIndex; i < numCards; i++)
      {
         myCards[i] = myCards[i + 1];
      }
      
      myCards[numCards] = null;
      return card; 
   }

   // Saves the entire hand to a string and returns it
   public String toString()
   {
      String handString = "Hand = ( ";
      for (int k = 0; k <= numCards - 1; k++)
      {
         if (myCards[k].getCardError() != true)
         {
            if (k == numCards - 1)
            {
               handString = handString + myCards[k].toString() + " )";
            } 
            else
            {
               handString = handString + myCards[k].toString() + ", ";
            }
         }
      }
      return handString;
   }

   // Returns the current number of cards in the array
   public int getNumCards()
   {
      return this.numCards;
   }

   // Returns a specific card from the array, or an invalid card if
   // index is bad 
   public Card inspectCard(int k)
   {
      if (k >= numCards)
      {
         return new Card('v', Card.Suit.spades);
      } 
      else
      {
         return myCards[k];
      }
   }
// calls arraysort to sort cards
   void sort()
   {
      Card.arraySort(myCards, numCards);
   }
}

/*
 * A class that represents the source of the cards for dealing and, as the game
 * progresses, the place from which players can receive new cards (say, as they
 * pick cards "from the deck" or when future hands are to be dealt from the same
 * deck).
 */
class Deck
{
   public final int MAX_CARDS = 6 * 56; // A maximum of six packs
   private static Card[] masterPack = new Card[56];
   private Card[] cards;
   private int topCard = 0;
   private static boolean initDeck = false;
   
   //added variable to truck number of packs
   private int packCount = 0;

   // Constructor
   public Deck()
   {
      allocateMasterPack();
      init(1);
      cards = masterPack;
      packCount = 1; 
   }

   // Constructors
   public Deck(int numPacks)
   {
      allocateMasterPack();
      init(numPacks);
      cards = masterPack;
      packCount = numPacks; 
   }
   
   //New method to add a card and check for how many copies there are against 
   //the number of decks in play
   public boolean addCard(Card card)
   {
      int cardRedundancy = 0;
      for(int i = 0; i < topCard; i++)
      {
         if(cards[i] != null)
         {
            if(cards[i].equals(card))
            {
               cardRedundancy++; 
            }
         }
      }
      if(cardRedundancy < packCount)
      {
         topCard++;
         cards[topCard - 1] = card;     
         return true;
      }
      else
      {
         return false; 
      }
      
   }
   
   //New method to check if a card exists in the deck and remove it. Top card
   // is placed where the removed card was.
   public boolean removeCard(Card card)
   {
      for(int i = 0; i < topCard; i++)
      {
         if(cards[i].equals(card))
         {
            cards[i] = cards[topCard];
            cards[topCard] = null; 
            topCard--; 
            return true;
         }
      }
      return false; 
   }
   
   // sorts the cards by rank using Card.arraySort
   void sort()
   {
      Card.arraySort(cards, topCard - 1);
   }
   
   // Re-populates the cards[] with new cards
   public void init(int numPacks)
   {
      cards = null;
      topCard = 0; 
      cards = new Card[numPacks * 56];
      for (int i = 0, j = 0; i <= (numPacks * 52) - 1; i++, j++)
      {
         if (j > 51)
            j = 0;
         cards[i] = masterPack[j];
         topCard++;
      }
   }
   //New method to get the number of cards in the deck (topCard)
   public int getNumCards()
   {
    return topCard;   
   }
   

   // Shuffles the cards[] by iteraing and placing card in each index randomly
   public void shuffle()
   {
      Card tempCard;
      Random rand = new Random();
      int firstCard;
      int secondCard;

      for (int i = 0; i < 1000; i++)
      {
         firstCard = rand.nextInt(topCard);
         secondCard = rand.nextInt(topCard);
         tempCard = cards[firstCard];
         cards[firstCard] = cards[secondCard];
         cards[secondCard] = tempCard;
      }
   }

   // Returns and removes the card in the top occupied position of cards[]
   public Card dealCard()
   {
      Card dealtCard = new Card();
      if (topCard >= 1)
      {
         dealtCard = cards[topCard - 1];
         topCard--;
         return cards[topCard];
      }
      dealtCard.set('v', Card.Suit.clubs);
      return dealtCard;
   }

   // Accessor for individual card
   public Card inspectCard(int k)
   {
      if (k > cards.length)
      {
         return new Card('v', Card.Suit.spades);
      } 
      else
      {
         Card card = new Card();
         card = cards[k];
         return card;
      }
   }

   // Private method that will be called by the constructor
   //is NOT supposed to add jokers according to instructions
   //jokers are added to deck for PhaseII in the randomCardGenerator
   private static void allocateMasterPack()
   {
      if (!initDeck)
      {
         int cardNum = 0;
         char[] cardVal =
         { 'A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K'};
         for (Card.Suit suit : Card.Suit.values())
         {
            for (char value : cardVal)
            {
               if (cardNum < 52)
               {
                  masterPack[cardNum] = new Card(value, suit);
                  cardNum++;
               }
            }
         }
         initDeck = true;
      }
   }
}