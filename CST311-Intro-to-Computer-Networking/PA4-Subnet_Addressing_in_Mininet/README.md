# PA4: Subnet Addressing and Routing in Mininet

The assignment requires you:
[1]to create a network described in the paragraph below using the program MiniEdit; 
[2] modify the initial Python script generated by MiniEdit so that hosts in different networks can send packets to each other; 
[3} modify the Python script so that one of the hosts (h2) runs a TLS-enabled simple web server; 
[4] modify the Python script so that one of the hosts (h4) runs the chat server your team developed in Programming Assignment (PA) #3, and is TLS-enabled;
[5] modify the Python script so that chat client program your team developed in PA #3 runs on both client hosts (h1 and h3), and is able to securely connect to the TLS-enabled chat server.
[6] using the Certificate Authority (CA) created in Lab 6, issue TLS server certificates for the webserver described in requirement [3] and to the chat server described in requirement [4]. Use common names (CN) for both servers that indicate what type of server each is, e.g. www.webpa4.test for the web server. 
[7] using Lab 6 as a guide, issue both TLS server certificates off-line in a separate script (Python or bash).  The only interactive part of the script should be a question asking for the CN of each server.  The other attributes of the Distinguished Name (DN) can be the same for both servers, and built into the script.  (The command to do this is described in Note 7 of Lab 6.  Remember also that you must modify the /etc/hosts file to include each server’s CN and IP address.)

You must submit the modified Python script and the certificate generation script per “Grading objectives” and a document as described in “What to turn in” below.  

The initial Python script will be a Level Two script generated by MiniEdit in the Mininet VM when you create the network described in the paragraph below.  You will have to modify this script so that all the hosts (h1, h2, h3, h4, r3, r4, and r5) can successfully ping each other, and the web server and chat applications are working correctly.  Name this script legacy_network.py

## Subnet addressing in Mininet 
In this assignment you will use MiniEdit on a Mininet VM to create a Python Level Two script that builds two hosts and two switches connected to each other by three legacy routers. (The command to start MiniEdit on a Mininet virtual machine is:  

```
mininet@mininet-vm~$ python2 ~/mininet/examples/miniedit.py)
```

(Note that this network design would not be used in a production system.  For security, the web server and the chat server would be located in different  subnets.)
In order to run miniedit.py, you must start your X11 server program to set up X11 forwarding on your machine. 
 
The code that is generated by exporting this network as a Level 2 Script in MiniEdit:

 ```
#!/usr/bin/python

from mininet.net import Mininet
from mininet.node import Controller, RemoteController, OVSController
from mininet.node import Host, Node
from mininet.node import OVSKernelSwitch, UserSwitch
from mininet.node import IVSSwitch
from mininet.cli import CLI
from mininet.log import setLogLevel, info
from mininet.link import TCLink, Intf
from subprocess import call

def myNetwork():

    net = Mininet( topo=None,
                   build=False,
                   ipBase='10.0.0.0/24')

    info( '*** Adding controller\n' )
    c0=net.addController(name='c0',
                      controller=Controller,
                      protocol='tcp',
                      port=6633)

    info( '*** Add switches\n')
    r5 = net.addHost('r5', cls=Node, ip='0.0.0.0')
    r5.cmd('sysctl -w net.ipv4.ip_forward=1')
    s2 = net.addSwitch('s2', cls=OVSKernelSwitch)
    s1 = net.addSwitch('s1', cls=OVSKernelSwitch)
    r4 = net.addHost('r4', cls=Node, ip='0.0.0.0')
    r4.cmd('sysctl -w net.ipv4.ip_forward=1')
    r3 = net.addHost('r3', cls=Node, ip='0.0.0.0')
    r3.cmd('sysctl -w net.ipv4.ip_forward=1')

    info( '*** Add hosts\n')
    h1 = net.addHost('h1', cls=Host, ip='10.0.0.1', defaultRoute=None)
    h2 = net.addHost('h2', cls=Host, ip='10.0.0.2', defaultRoute=None)
......h3 = net.addHost('h1', cls=Host, ip='10.0.0.3', defaultRoute=None)
    h4 = net.addHost('h2', cls=Host, ip='10.0.0.4', defaultRoute=None)





    info( '*** Add links\n')
    net.addLink(h1, s1)
    net.addLink(h2, s1)
    net.addLink(h3, s2)
    net.addLink(h4, s2)
    net.addLink(s2, r5)
    net.addLink(s1, r3)
    net.addLink(r3, r4)
    net.addLink(r4, r5)

    info( '*** Starting network\n')
    net.build()
    info( '*** Starting controllers\n')
    for controller in net.controllers:
        controller.start()

    info( '*** Starting switches\n')
    net.get('s2').start([c0])
    net.get('s1').start([c0])

    info( '*** Post configure switches and hosts\n')

    CLI(net)
    net.stop()

if __name__ == '__main__':
    setLogLevel( 'info' )
    myNetwork()
```

Executing this code 

```
mininet@mininet-vm~$:sudo python legacy_network.py

```

results in:

```
*** Adding controller
*** Add switches
*** Add hosts
*** Add links
*** Starting network
*** Configuring hosts
r3 r4 r5 h1 h2
*** Starting controllers
*** Starting switches
Traceback (most recent call last):
  File "legacy_network.py", line 64, in <module>
    myNetwork()
  File "legacy_network.py", line 54, in myNetwork
    net.get('s2').start([c0])
  File "build/bdist.linux-i686/egg/mininet/node.py", line 1165, in start
  File "build/bdist.linux-i686/egg/mininet/node.py", line 1166, in <genexpr>
  File "build/bdist.linux-i686/egg/mininet/node.py", line 1132, in intfOpts
  File "build/bdist.linux-i686/egg/mininet/node.py", line 1075, in isOldOVS
AttributeError: type object 'OVSSwitch' has no attribute 'OVSVersion'
```

Your first tasks are to modify this program (perhaps using different IP addresses) so that the legacy routers can forward packets between the four hosts and each other.  But first, you must get rid of the “build errors”.  These errors occur because of the order that MiniEdit creates the switches and legacy routers.  To get rid of these errors, move the two lines instantiating switches s1 and s2 ahead of the legacy router instantiations in the section of code labeled info( '*** Add switches\n')

Now to continue with the assignment, you will need to understand Internet addressing, subnets, and the function of a router as described in the “IPv4 Addressing” Section of Kurose and Ross (4.3.3 in 7th Edition).  There are certain rules you must follow for this assignment:

a.	Hosts h1 and h2 and the router r3 interface connected to s1 will be on a 254-host network with the private IPv4 address of 10.0.x.0/24.  (You choose the value of x.)
b.	Hosts h3 and h4 and the router r5 interface connected to s2 will be on a network with the private IPv4 address of 10.0.y.0/24.  (You choose the value of y.)
c.	The link between router r3 and router r4 will be a 2-host network with the IPv4 address of 192.168.a.b.  (You choose the values of a and b.)  Hint: Remember a 2-host network must also include the IP address of the network number and the broadcast address.
d.	The link between router r4 and router r5 will be a 2-host network with the IPv4 address of 192.168.c.d.  (You choose the values of c and d.) 
The Level Two script has already inserted the commands to make r3, r4, and r5 routers.  You will have to add static routes (or static and default routes) to make this network work.  Six static routes (or six static plus default) routes are required so that all devices can ping each other  

You may find the example Python programs in ~/mininet/examples helpful - in particular, linuxrouter.py.  We suggest executing that program and studying it to understand how you will need to modify legacy_network.py.  
 
 
Grading Rubric and Objectives 
1.	(30 points) Correct Network design that follows the IP addressing rules for this assignment, listed above, and allows all the hosts to successfully ping each other. Draw and submit the network design in pdf format with all interfaces labelled with interface names (e.g., s1-eth1) and interface IP addresses.
2.	(20 points) Screen capture of the program that runs with no Python errors.
3.	(20 points) Screen capture of successful pingall at the mininet> prompt.   (5 points are given if h1, h2, h3 and h4 can successfully ping each other, but pingall is not successful.) 
4.	(15 points) A list of lines that were changed and why
5.	(30 points) Answers to these questions: 
    a.	What were any interesting findings and lessons learned?  
    b.	Why didn’t the original program forward packets between the hosts? 
    c.	Is the line ‘ r3.cmd('sysctl -w net.ipv4.ip_forward=1') ’ required? 
    d.	Intentionally break your working program, e.g.: change a subnet length, IP address, or default route for a host. Explain why your change caused the network to break. 
6.	(25 points total) Screen capture of a successful chat session between the two chat clients (15 points) and a screen capture of a Wireshark trace of the communication between a chat client and the chat server (10 points).  For the Wireshark trace, you must select the Server Hello packet, and in the packet details, expand the TLS Record Layer Server Key Exchange after expanding the Transport Layer Security.
7.	(25 points) Screen capture of the successful wget (or curl) of the web server index file.
8.	(20 points) Screenshot of both decrypted server (web and chat) certificates.
9.	(40 points) Your modified legacy_network.py program as a separate python file. 
10.	(30 points) Submission files expected - 
a.	Minutes of the 3 meetings
b.	1 pdf document with deliverables of Steps 1 through 8.
c.	1 legacy_network.py python script 
d.	1 TLS chat server and 1 TLS chat scripts
e.	1 Python or bash script that issues server certificates for the web server and chat server. 


The two end routers represent the border routers for a company at two locations; the third router represents the Internet.  Consider h1, h2, s1 and r3 to be at a West Coast site and h3, h4, s2, and r5 to be at an East Coast site. You will modify Level Two script such that all the hosts and routers can ping each other.  This requires that you understand subnet addressing, the function of a router, and the configuration of static routes.  (The mininet command pingall will show if you are successful.)

![image](https://github.com/Jamham1020/final-projects/assets/64275401/1d671a28-1b28-434e-895b-328381e211d6)


Notes to Help with this Assignment :

1. Link to a helpful hint about assigning IP addresses to the legacy routers in MiniEdit:   Note on Assigning IP Addresses to Legacy RoutersLinks to an external site.

2. Link to hints on assigning static routes:  PA#4 Helpful Hints on Static RoutesLinks to an external site.

3. Here is a quick demo video of PA4 requirements 4 and 5 and you can apply it for requirement 3 as well.

Some notes on this demo:

linuxrouter.py example with my modifications was used instead of the actual PA4 topology to quickly test the makeTerm api
the mininet topology includes three hosts connected to a legacy router.
chat server was launched from the script on h1
chat clients were also launched from the script on h2 and h3
use the -E flag after sudo when launching your python Level 2 script  (not shown in video)
4. Link to sample TLS-enabled TCP server and client scripts.Links to an external site.

These scripts are modifications of the Programming Assignment #1 TCP client and server scripts as explained in the document:  TLS-enabling TCP Server and ClientLinks to an external site.

5.  If you want to programmatically run commands on an xterm terminal of a host, then use the makeTerm api as follows:
makeTerm( node, title='Node', term='xterm', display=None, cmd='bash' )
where
node is the host
cmd is whatever commands you want to run
Reference: https://github.com/mininet/mininet/blob/master/mininet/term.py
